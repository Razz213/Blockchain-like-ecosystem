import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.Timestamp;
import java.util.ArrayList;
import java.util.Date;
import java.util.Random;

import org.apache.commons.codec.binary.Hex;
import org.apache.commons.codec.binary.StringUtils;
import org.apache.commons.codec.digest.DigestUtils;

public class Block {


    /**Is the position of this block in the entire chain*/
    private int index;
    /**Obviously the timestamp when the block was generated*/
    private String timestamp;
    /**Is the hash value generated by this block through the SHA256 algorithm*/
    private String hash;
    /**A SHA256 hash pointing to the previous block*/
    private String prevHash;

    private String nonce;
    private String merkleRoot;


    // used for optional hash function
    private int target;
    private int version;
    private String hashHeaderBlock;
    public ArrayList<Transaction> data = new ArrayList<>();
    Random rn = new Random();

    // constructor
    public Block(){
        this.timestamp = ""+System.currentTimeMillis();
    }

    /** getters and setters**/
    public int getIndex() {
        return index;
    }

    //todo hash twice in merkle tree

    public void setIndex(int index) {
        this.index = index;
    }

    public String getTimestamp() {
        return timestamp;
    }

    public void setTimestamp(String timestamp) {
        this.timestamp = timestamp;
    }

    public String getHash() {
        return hash;
    }

    public void setHash(String hash) {
        this.hash = hash;
    }

    public String getPrevHash() {
        return prevHash;
    }

    public void setPrevHash(String prevHash) {
        this.prevHash = prevHash;
    }

    public int getTarget() {
        return target;
    }

    public void setTarget(int target) {
        this.target = target;
    }

    public String getNonce() {
        return nonce;
    }

    public void setNonce(String nonce) {
        this.nonce = nonce;
    }

    public void setVersion(int version) {
        this.version = version;
    }

    public void setMerkleRoot(String merkleRoot) {
        this.merkleRoot = merkleRoot;
    }

    public int getVersion() {
        return version;
    }

    public String getMerkleRoot() {
        return merkleRoot;
    }


    /* (non-Javadoc)

     * @see java.lang.Object#hashCode()

     */

    @Override

    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + target;
        result = prime * result + ((hash == null) ? 0 : hash.hashCode());
        result = prime * result + index;
        result = prime * result + ((nonce == null) ? 0 : nonce.hashCode());
        result = prime * result + ((prevHash == null) ? 0 : prevHash.hashCode());
        result = prime * result + ((timestamp == null) ? 0 : timestamp.hashCode());
        return result;
    }
    // concatenate the header and sha256 X2
    public static String calculateHash(Block block) throws NoSuchAlgorithmException {
        String record = block.getIndex() + block.getTimestamp() + block.getNonce() + block.getPrevHash()+block.getMerkleRoot();
        MessageDigest digest = MessageDigest.getInstance("SHA-256"); //hash twice 
        byte[] hash = digest.digest(StringUtils.getBytesUtf8(record));
        byte[] hash1 = digest.digest(StringUtils.getBytesUtf8(hash.toString()));
        return Hex.encodeHexString(hash1);
    }

    public String mineBlock() throws NoSuchAlgorithmException {
        this.merkleRoot = CommonUtils.getMerkleRoot(data);
        String target = CommonUtils.getDificultyString(this.target); //Create a string with difficulty * "0"

        hash = calculateHash(this);

        // checking if the new hash start with N target 0s. If not, we change the nonce randomly
        while(!hash.substring( 0, this.target).equals(target)) {
            this.nonce = rn.toString();
            hash = calculateHash(this);
            System.out.println(hash);
        }
        return "----> "+hash;
    }

  public boolean addTransaction(Transaction transaction) throws NoSuchAlgorithmException {
      //process transaction and check if valid, unless block is genesis block then ignore.
      if(transaction == null){
          return false;
      }
      if((!"0".equals(prevHash))) {
          if((transaction.processTransaction() != true)) {
              System.out.println("Transaction failed to process. Discarded.");
              return false;
          }
      }

      data.add(transaction);
      System.out.println("Transaction Successfully added to Block");
      return true;
  }

    @Override

    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        Block other = (Block) obj;
        if (target != other.target)
            return false;
        if (hash == null) {
            if (other.hash != null)
                return false;
        } else if (!hash.equals(other.hash))
            return false;
        if (index != other.index)
            return false;
        if (nonce == null) {
            if (other.nonce != null)
                return false;
        } else if (!nonce.equals(other.nonce))
            return false;
        if (prevHash == null) {
            if (other.prevHash != null)
                return false;
        } else if (!prevHash.equals(other.prevHash))
            return false;
        if (timestamp == null) {
            if (other.timestamp != null)
                return false;
        } else if (!timestamp.equals(other.timestamp))
            return false;
        return true;
    }
}
